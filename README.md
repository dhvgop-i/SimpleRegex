RegexFSM
Опис

Цей проєкт реалізує кінцевий автомат (FSM, Finite State Machine) для перевірки відповідності рядків простим регулярним виразам. Клас RegexFSM приймає регулярний вираз, будує на його основі автомат, а потім дозволяє перевірити, чи відповідає заданий вхідний рядок цьому виразу.

Підтримуються наступні елементи регулярного виразу:

    ASCII-символи (наприклад, a, b, x, 1, тощо)

    . — будь-який ASCII-символ

    * — нуль або більше входжень попереднього символу або конструкції

    + — одне або більше входжень попереднього символу

Призначення

Метою даної реалізації є демонстрація роботи автоматів з регулярними виразами, включаючи побудову графу станів та рекурсивну перевірку входження рядка до мови, що описується регулярним виразом.
Архітектура
Клас State

Абстрактний базовий клас для всіх типів станів автомата. Визначає обов’язкові методи:

    check_self(char: str) -> bool — перевіряє, чи відповідає символ поточному стану.

    check_next(next_char: str) -> State | Exception — визначає наступний стан на основі символу.

    __bool__() — визначає, чи є стан "істинним" (успішним). У термінального стану повертає False.

Кожен стан має список next_states, що містить можливі наступні стани автомата.
Конкретні стани

    StartState — початковий стан автомата.

    TerminationState — фінальний стан, відповідає успішному завершенню рядка.

    DotState — відповідає символу . у регулярному виразі. Приймає будь-який ASCII-символ.

    AsciiState — відповідає одному конкретному ASCII-символу.

Клас RegexFSM

Основний клас, який:

    Приймає регулярний вираз у конструкторі (__init__).

    Будує відповідний автомат.

    Містить метод check_string(s: str) -> bool для перевірки відповідності рядка.

Побудова автомата

Метод __init__ проходить по символах регулярного виразу та будує послідовність станів:

    Для символів ., a, b тощо створюються відповідні DotState або AsciiState.

    Для символу * позначається, що попередній стан може повторюватися довільну кількість разів (через атрибут stared = True).

    Символ + повторює попередній стан один або більше разів (без додаткової логіки, просто повертає попередній стан).

Метод find_next рекурсивно визначає, які стани мають бути приєднані до повторюваних конструкцій, і виконує відповідні з'єднання між ними.
Перевірка рядка

Метод check_string реалізує рекурсивну перевірку рядка на відповідність регулярному виразу через обхід у глибину (dfs). Враховуються:

    Поточний символ і чи відповідає він поточному стану.

    Повторення символів при наявності * або +.

    Завершення перевірки при досягненні кінця рядка та переходу в термінальний стан.

Опис алгоритму
При створені екземпляра класу RegexFSM створюється скінченний автомат, де є термінальний стан, пчатковий стан, стан . та стан ascii,
де останній відповідає за зчитування конкретного числа чи літери, а . відповідає за зчитування довільного числа чи літери.
Для реалізації + додається цикл в заданій "вершині"(стані), а для реалізації * додається цикл в заданому стані, а також шлях з попереднього 
стану в наступний після того, що містить *.
Далі при перевірці рядка використовується DFS для обходу скінченного автомата за тією логікою, що і графа. Тоді якщо при такому обході ми знайшли 
хоча б 1 шлях для побудови заданого рядка в нашому автоматі, тоді ми повертаєми істину. Якщо ж ми не знайшли жодного шляху, котрий би будував шуканий 
рядок і пройшли таку кількість станів, яка рівна довжині рядка, тоді повертаємо хибу

Приклад використання

fsm = RegexFSM("a*b.")
print(fsm.check_string("aaabx"))  # Повертає True
print(fsm.check_string("b1"))    # Повертає False

Обмеження

    * та + працюють лише з одним попереднім станом.

    Підтримується лише базовий набір ASCII-символів.
